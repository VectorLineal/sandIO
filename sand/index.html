<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <title>sand.io</title>
	<script type="text/javascript" src="js/main_layer/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var config = {
    type: Phaser.AUTO,
    parent: '',
    width: window.innerWidth * window.devicePixelRatio,
    height: window.innerHeight * window.devicePixelRatio,
    backgroundColor: '#fbf0e4',
    physics: {
        default: 'matter',
        matter: {
            debug: true,
            gravity:{
                x: 0,
                y:0
            }
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    title: 'sand',
    pixelArt: true
};

var game = new Phaser.Game(config);

function preload() {

    //game.load.spritesheet('minotaur_warrior', 'assets/warrior_minotaur.png', 60, 76, 10);
    this.load.spritesheet('minotaur_warrior', 'assets/warrior_minotaur_test.png', {frameWidth: 60, frameHeight: 76});
    this.load.tilemapTiledJSON('duelMap', 'assets/duel_map.json');
    this.load.image('tiles', 'assets/maptiles.png');

}
//muy importante para hacer escalado de forma correcta
var scaleRatio = window.devicePixelRatio*3;
//objetos que se renderizan
var map;
var layer;
var player;
//controles
var up;
var down;
var left;
var right;
var spell1;
var spell2;
var spell3;
var spell4;
var spell5;
var consumable1;
var consumable2;
var shop;
var cancel;

var lastKeyPressed = "";

function create() {

    //map generation
    map = this.make.tilemap({key: 'duelMap'});

    var tileset = map.addTilesetImage('maptiles', 'tiles');

    layer = map.createStaticLayer("duel", tileset, 0, 0);
    layer.setScale(scaleRatio);
    this.cameras.main.setBounds(0, 0, 960 * scaleRatio, 1600 * scaleRatio);
    this.matter.world.setBounds(0, 0, 960 * scaleRatio, 1600 * scaleRatio);
    
    // The player and its settings
    //hay que asegurarse que el body quede cuadrado puesto que no se puede rotar
    //13 y -34 representan la diferencia de pixeles que se pretende eliminar para poner el cuerpo fisico solo en el personaje, no el arma ni nada más
    player = this.matter.add.sprite(480 * scaleRatio, 800 *scaleRatio, 'minotaur_warrior', null, {
        shape: {
            type: 'rectangle',
            width: 46,
            height: 41
        },
        render:{ sprite: { xOffset:((13+(46/2))/60) - 0.5, yOffset:-((34/2)/76)}}
    });
    player.setScale(scaleRatio);

    //animations
    var attackSpeed=600;

    this.anims.create({
        key: 'attack',
        frames: this.anims.generateFrameNumbers('minotaur_warrior', { frames: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 4, 0] }),
        frameRate: (13*attackSpeed)/200
    });

    this.anims.create({
        key: 'spell1',
        frames: this.anims.generateFrameNumbers('minotaur_warrior', { frames: [0, 11, 12, 13, 14, 12, 0] }),
        frameRate: 10
    });

    this.anims.create({
        key: 'spell4',
        frames: this.anims.generateFrameNumbers('minotaur_warrior', { frames: [0, 10, 10, 10, 10, 10, 10, 0] }),
        frameRate: 10
    });

    player.on('animationcomplete', changeAction, this);

    //  Our controls.
    up = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
    down = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    left = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
    right = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
    spell1 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);
    spell2 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);
    spell3 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
    spell4 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
    spell5 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.V);
    consumable1 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ONE);
    consumable2 = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.TWO);
    shop = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.I);
    cancel = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
    //input
    //this.input.mouse.disableContextMenu(); se reactiva en producción
    this.input.on('pointermove', adjustPlayerRotation, this);

    //camera
    this.cameras.main.startFollow(player, true, 1, 1);
}

var previousAnim;
function update() {
    var speed = 30/scaleRatio;
    var pointer = this.input.activePointer;

    player.setVelocity(0);

    if (left.isDown) {
        player.setVelocityX(-speed);
    }
    else if (right.isDown) {
        player.setVelocityX(speed);
    }

    if (up.isDown) {
        player.setVelocityY(-speed);
    }else if (down.isDown) {
        player.setVelocityY(speed);
    }

    if(cancel.isDown){
        lastKeyPressed = "";
    }

    if(pointer.isDown){
        if(!player.anims.isPlaying){
            switch(lastKeyPressed){
            case "q":
                player.anims.play('spell1');
                break;
            case "r":
                player.play('spell4');
                break;
            default:
                player.play('attack');
                break;
        }
        }
    }

    if (spell1.isDown){
		lastKeyPressed = "q";
	} else if(spell4.isDown){
        lastKeyPressed = "r";
    }
}

function changeAction(animation, frame){
    lastKeyPressed = "";
}

function adjustPlayerRotation(pointer) {
    var camera = this.cameras.main;
    var angle = -90 + (Phaser.Math.RAD_TO_DEG * Phaser.Math.Angle.Between(player.x, player.y, pointer.x + camera.scrollX, pointer.y + camera.scrollY));
    player.setAngle(angle);
}

</script>

</body>
</html>